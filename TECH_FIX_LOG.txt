Журнал внедрения улучшений ЖильеGO
==============================

Этап 1 (инициализация): Создан журнал этапов исправлений.
Этап 2 (безопасность базовой конфигурации):
- В settings скорректированы ALLOWED_HOSTS по умолчанию и удалено глобальное отключение CSRF.
- Добавлено обязательное требование ENCRYPTION_KEY.
- Сервис шифрования теперь отказывается работать без ключа.

Этап 3 (план следующих улучшений):
- Подготовить сервисный слой (booking/payment/notification) и начать декомпозицию telegram handlers.
- Перевести обработчики Telegram-бота на async и вынести блокирующие вызовы.
- Перенести NotificationService на фоновые задачи Celery и внедрить отказоустойчивые ретраи.
- Разработать стратегию синхронизации календаря при бронированиях для всех каналов.
- Настроить кэширование Redis, мониторинг (Prometheus/Sentry) и обновить тестовый контур.

Этап 4 (сервисный слой — бронирования):
- Создан пакет booking_bot/services с booking_service.py.
- Реализованы BookingRequest, create_booking, cancel_booking и calculate_total_price.

Этап 5 (REST API использует сервис бронирований):
- BookingViewSet.perform_create перенесён на create_booking с обработкой ошибок BookingError.
- Действие cancel теперь использует cancel_booking сервисного слоя и сохраняет cancelled_by.

Этап 6 (следующие шаги):
- Интегрировать booking_service в Telegram/WhatsApp потоках и унифицировать блокировку календаря.
- Начать декомпозицию telegram_bot.handlers на модули + переход на async.
- Перенести NotificationService на отложенную обработку через Celery, добавить ретраи.
- Подготовить кэширование Redis для поиска и метрики (Prometheus/structlog/Sentry).

Этап 7 (бот использует сервис бронирований):
- handle_payment_confirmation в Telegram вызывает create_booking с блокировкой календаря и обработкой BookingError.
- Настроено планирование auto-cancel через таск, логика оплаты очищает состояние после успеха/ошибок.

Этап 8 (оценка WhatsApp-потока):
- Обнаружено прямое использование Booking.objects.create в booking_bot/whatsapp_bot/handlers.py:939; требуется аналогичная интеграция с сервисным слоем.
- Задача запланирована на следующий цикл вместе с общим рефакторингом бота.

Этап 9 (WhatsApp-бот на сервисном слое):
- handle_payment_confirmation в WhatsApp использует BookingRequest/create_booking и планирует автоотмену.
- Убраны прямые Booking.objects.create, платежи используют booking.total_price.

Этап 10 (план рефакторинга ботов и уведомлений):
- Подготовить выделение модулей telegram_bot.payment_flow и telegram_bot.booking_flow для async-обработчиков.
- Аналогично декомпозировать whatsapp_bot на подмодули (state management, payments).
- Перевести send_booking_confirmation и связанные функции на единый сервис уведомлений, переиспользуемый ботами.
- Переписать NotificationService на Celery задачи и структурированные логи.

Этап 11 (декомпозиция Telegram бота):
- Создан модуль booking_bot/telegram_bot/payment_flow.py с handle_payment_confirmation и send_booking_confirmation.
- Из handlers.py удалена громоздкая логика оплаты; импорты упрощены.
- send_booking_confirmation сохраняет отправку кодов и запрос отзывов с защитой от ошибок.

Этап 12 (следующие шаги по уведомлениям):
- Выделить общие функции уведомлений ботов в сервис notification_delivery.
- Переписать NotificationService на Celery-задачи с ретраями и structured logging.
- Подготовить набор интеграционных тестов ботов и уведомлений после рефакторинга.

Этап 13 (общие уведомления ботов):
- Создан booking_bot/notifications/delivery.py с генерацией текстов и логированием кодов доступа.
- Telegram payment_flow и WhatsApp handlers используют общие функции для отправки подтверждений.

Этап 14 (NotificationService refactor план):
- Вынести синхронный вызов process_queue в Celery таску.
- Ввести новую задачу notifications.tasks.process_queue_async, использующую log delivery.
- Обновить места вызова NotificationService.schedule для асинхронной обработки.

Этап 15 (асинхронная обработка уведомлений):
- NotificationService.schedule теперь вызывает Celery-задачу process_notification_queue вместо синхронного process_queue.
- При ошибке постановки в очередь выполнен запасной синхронный запуск.

Этап 16 (декомпозиция booking flow):
- Создан booking_bot/telegram_bot/booking_flow.py с обработчиками начала бронирования и выбора дат/времени.
- handlers.py теперь импортирует эти функции и избавлен от дублирования логики.

Этап 17 (план state-manager):
- Вынести навигацию поиска, обновление состояний и отмену бронирования в отдельный модуль state_flow.py.
- Подготовить каркас для async-хендлеров с согласованным интерфейсом.

Этап 18 (state_flow внедрение):
- Реализован полноценный booking_bot/telegram_bot/state_flow.py: вынесены поиск, избранное, карточки и отмена брони, добавлено единое управление причинами отмены.
- handlers.py и связанные модули переключены на state_flow; добавлена маршрутизация состояний STATE_CANCEL_* и удалены дублирующие реализации.
- Обновлены main.py, bot_setup.py, user_review_handlers.py и views.py для использования новых импортов, проверена компиляция python-модулей.

Этап 19 (кэширование поиска):
- Добавлена конфигурация Django Cache с поддержкой Redis/LocMem и параметры SEARCH_CACHE_* в settings.py.
- Реализован booking_bot/listings/cache.py с кешированием результатов поиска, сигналами инвалидции и интеграцией в state_flow.show_search_results.
- Обновлены зависимости (django-redis), добавлены сигнал-подписчики и очищены строки уведомлений для успешной компиляции.

Этап 20 (observability):
- Подключены django-prometheus и маршрут /metrics, база переведена на инструментированный backend.
- В settings.py настроен structlog JSON-логгер и добавлены Prometheus middleware; healthz теперь логирует в структурированном формате.
- Добавлены зависимости django-prometheus и structlog, обновлены urls и проверена компиляция модулей.

Этап 21 (унификация пользователей и платежей):
- Переведены все ForeignKey/OneToOne на settings.AUTH_USER_MODEL, добавлены миграции и защита от сохранения профилей без пользователя.
- Обновлены сериализаторы, вьюхи и тесты для использования get_user_model и безопасного отображения username.
- Исправлены Telegram-бот (удален конфликт импортов) и тесты бронирований с корректным импортом Property.
- Приведена интеграция Kaspi refund к единой конфигурации (KASPI_REFUND_URL) и добавлены дефолты в settings.
- Пересобран requirements.txt до поддерживаемых мажорных версий без фиктивных релизов 2025 года.

Этап 22 (tests — Telegram user flow):
- Настроен тестовый каркас с заглушками Telegram API и Kaspi в booking_bot/telegram_bot/tests.
- Добавлен сценарный тест test_user_flow.py, покрывающий цепочку start → поиск → бронирование → оплата/отмена.
- Тест проверяет состояние FSM, создание брони и отправку ключевых сообщений (подтверждение оплаты, запрос отзыва).

Этап 23 (Kaspi webhook hardening):
- Реализована HMAC-SHA256 проверка подписи в booking_bot/payments/kaspi_service.verify_webhook_signature с валидацией timestamp и защитой от отсутствия секрета.
- kaspi_payment_webhook теперь валидирует подпись до разбора JSON и отвечает 403 при неверной или устаревшей подписи.
- Тесты webhook обновлены: добавлены генерация подписи, проверка невалидной подписи и покрытия таймстампа в booking_bot/payments/tests_views.py.

Этап 24 (эмуляция Kaspi-платежей):
- В settings добавлена настройка AUTO_CONFIRM_PAYMENTS с поддержкой env-переключения; по умолчанию включена эмуляция.
- Telegram- и WhatsApp-потоки оплаты используют AUTO_CONFIRM_PAYMENTS вместо DEBUG, что позволяет мгновенно подтверждать оплату при нажатии в боте.
- Временный режим упрощает тестирование без реальной интеграции Kaspi.

Этап 25 (ускорение эмуляции оплаты):
- Удалены блокирующие задержки time.sleep из auto-confirm сценариев Telegram и WhatsApp для мгновенного подтверждения.
- Поведение платежа остаётся зависимым от AUTO_CONFIRM_PAYMENTS и не тормозит обработку сообщений.

Этап 26 (устойчивость NotificationService):
- NotificationService сериализует контекст и metadata перед записью в JSONField, замещая модели, даты и Decimal безопасными значениями.
- Добавлен unit-тест, проверяющий сохранение контекста с Django моделями без потери данных (booking_bot/notifications/tests/test_service.py).

Этап 27 (ролевой контур):
- Добавлена роль super_user с полными правами, расширены ROLE_CHOICES и помощники в UserProfile.
- Все проверки доступа обновлены, чтобы учитывать super_user наряду с admin и super_admin; миграция синхронизирована с новыми ролями.

Этап 28 (reply-интерфейс Telegram):
- Весь Telegram-интерфейс переведён на ReplyKeyboardButton: поиск, бронирования и админский контур больше не используют inline-кнопки.
- Переписаны admin_property_handlers: списки объектов, карточки, бронирования, отзывы и меню редактирования работают через состояния и текстовые кнопки.
- Обработчик callback query заменён подсказкой, а фоновые напоминания о рейтинге отправляют reply-клавиатуру и выставляют нужное состояние.

Этап 29 (автозапуск меню, альтернативная оплата и аналитика):
- Telegram-бот автоматически показывает главное меню при первом сообщении без /start; WhatsApp получил аналогичный выбор manual оплаты.
- Добавлен альтернативный сценарий оплаты через счёт в Telegram и WhatsApp, с настройками MANUAL_PAYMENT_* и удержанием календаря.
- В сервисе бронирований и вебхуках внедрён пересчёт статуса квартиры на основании активных броней.
- Расширены отчёты: топ-5 квартир, гостей и риелторов, сводка отмен и улучшенный блок статистики в Telegram/WhatsApp админ-интерфейсах.

Этап 30 (соответствие ТЗ: уведомления, аналитика, админка):
- В NotificationTemplate добавлены события update_photos_needed/update_price_needed/high_ko_factor и снят уникальный ключ по полю event.
- NotificationService научился авто-создавать шаблоны по умолчанию, расширена логика выбора каналов, а в задачах бронирований передаётся расширенный контекст (названия квартир, проценты, рекомендации).
- Добавлен экспорт аналитики в CSV в Telegram-боте: кнопка «📥 Экспорт в CSV» доступна во всех режимах (общие, риелторы, агентства) и формирует вложение через Bot API.
- В админке Django реализованы история цен и тепловая карта занятости: PropertyAdmin использует новый шаблон с Chart.js-графиком и цветовым гридом на 30 дней, а модель PropertyPriceHistory ведёт автоматический журнал цен.
- pyproject.toml получил полный список run-time зависимостей и optional dev-набор, что позволяет устанавливать проект командами pip/uv без requirements.txt.

Этап 31 (безопасность — Claude Code):
- Добавлены зависимости django-ratelimit>=4.1 и sentry-sdk>=1.40 в requirements.txt для защиты от DoS и мониторинга ошибок.
- Исправлены ошибки импорта в telegram_bot/handlers.py: закомментирован неопределённый handle_review_photo_upload в PHOTO_UPLOAD_HANDLERS, перемещён словарь STATE_TEXT_HANDLERS в конец файла для устранения forward reference errors.
- Добавлен декоратор @ratelimit(key='ip', rate='100/m') на telegram_webhook и whatsapp_webhook для ограничения частоты запросов (max 100 POST/минуту на IP).
- В settings.py добавлена проверка AUTO_CONFIRM_PAYMENTS: при DEBUG=False и AUTO_CONFIRM_PAYMENTS=True выбрасывается ImproperlyConfigured, что предотвращает эмуляцию платежей в продакшене.
- В Booking.clean() добавлена валидация пересечений бронирований: при создании/редактировании проверяется наличие конфликтующих броней (status='confirmed'/'pending_payment') и выбрасывается ValidationError при совпадении дат.
- Созданы базовые unit-тесты в bookings/tests_security.py для проверки валидации пересечений (test_booking_overlap_validation, test_booking_no_overlap_validation).
- Обновлён docker-compose.yml: добавлены проброс портов 5432:5432 для PostgreSQL и 6379:6379 для Redis, чтобы Django мог подключаться к контейнерам локально.
- Для локального запуска скорректирован .env: DB_HOST=localhost, REDIS_HOST=localhost, CELERY_BROKER_URL использует localhost вместо docker-имён (db/redis).
- Применены все миграции БД (listings.0003_propertypricehistory, notifications.0003_update_event_choices, users.0003_realestateagency).
- Исправлена ошибка в PropertyAdmin: удалены дублирующие поля key_safe_code и digital_lock_code из fieldsets (используются зашифрованные версии через @property), также удалены незамигрированные поля из модели Property.
- Исправлена конфигурация MinIO: синхронизированы credentials в .env (S3_ACCESS_KEY=minio_access_key, S3_SECRET_KEY=minio_secret_key) с docker-compose.yml, изменён S3_ENDPOINT_URL на localhost для локального запуска Django.
- Исправлена ошибка загрузки PNG с прозрачностью: в PhotoStorage._create_thumbnail() добавлена конвертация RGBA -> RGB с белым фоном перед сохранением в JPEG формат, что устраняет ошибку "cannot write mode RGBA as JPEG".
- Улучшен UX пустого результата поиска в telegram_bot/state_flow.py: изменён текст сообщения на "К сожалению, подходящих вам квартир мы не смогли найти, попробуйте изменить свои критерии для поиска", добавлена кнопка "🔄 Новый поиск" (ведёт себя идентично "🔍 Поиск квартир") и кнопка "🧭 Главное меню" для улучшения навигации.
- Исправлена критическая ошибка в потоке поиска квартир: функции select_class() и select_rooms() теперь правильно сохраняют состояние с учётом base_filters и refined_filters (аналогично select_district), что устраняет проблему "не работает после выбора комнат"; добавлена недостающая функция log_state_transition для отладки переходов между состояниями.
- Проект успешно прошёл `manage.py check`, все зависимости установлены, тестовая среда запущена.
